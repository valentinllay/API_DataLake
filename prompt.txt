Bonjour !  
Je construis une API Flask Python dont les endpoints exposent des requêtes SQL paramétrables vers ma base de données MySQL (AWS RDS). Voici mon contexte et mes contraintes, à intégrer d’emblée :

1. Contexte global  
   - J’ai déjà une pipeline ETL Python qui met à jour la même base (`ltv_computation`).  
   - Je veux **réutiliser** la même configuration et la même connexion SQL (pool, SSL RDS) dans mon API sans duplication donc il faut les centraliser.
   - L'application est petite mais je veux mettre l'accent sur la **qualité** du code python.

2. Objectif principal  
   - Fournir des endpoints **génériques** qui acceptent en query parameters (ou JSON body) des filtres (`age`, `borrowers`, `insee_code`, etc.) et exécutent en toute sécurité **des requêtes SQL dynamiques** (SELECT, AVG, JOINs, etc.).  
   - Les endpoints ne sont pas figés : je pourrais en ajouter pour d’autres tables ou calculs.

3. Exigences côté client  
   - Les consommateurs peuvent être des scripts VBA/Excel (GET sans body ou POST avec body) ou des clients Python/JS (GET ou POST).  
   - Les réponses doivent être renvoyées dans un format `{ status, meta, data }` ou CSV, facile à parser dans tous les environnements.

4. Architecture et modules  
   - **config.py** : centralise uniquement les variables d’environnement et constantes (DB URI, SSL CA path, DEBUG, API_PREFIX…). Je ne veux pas gérer moi même les Pools
   - **db.py** : factory `create_db_engine()` (SQLAlchemy ou DBUtils + pymysql) + session/pool global.  
   - **repository.py** : contient **seulement** les fonctions SQL brutes, prenant des paramètres et retournant des résultats (fetchone, fetchall).  
   - **services.py** : logic métier, composition de plusieurs appels repository, transformation en structures Python (dict/list).  
   - **routes.py** : définition des endpoints Flask, validation des params, appel aux services, gestion des codes d’erreur HTTP.  
   - **app.py** : assemble Flask, configure logging, enregistre les routes, lance `app.run()`. Je ne veux pas de blueprint.  
   - **requirements.txt** : lister flask, sqlalchemy/pymysql, python-dotenv, etc.

5. Sécurité & bonnes pratiques  
   - **Pas de SQL injection** : utiliser `text()` ou requêtes paramétrées, jamais de concaténation directe.  
   - **Pool** et **pre-ping** pour la robustesse avec AWS RDS mais je ne veux pas les gérer moi même dans le code. Si SQL Alchemy peut le faire sous le chapeau c'est mieux.  
   - **Logging**, `abort()` pour les 400/404/500, handlers d’erreur globaux.  
   - **GET** pour lectures simples/idempotentes, **POST** pour payloads complexes.  
   - Configurable via `.env` ou variables d’environnement, pas de secrets en dur.

6. Extensibilité  
   - Pouvoir ajouter facilement de nouveaux endpoints pour d’autres tables, d’autres agrégations (AVG, COUNT, GROUP BY) ou des calculs personnalisés.  
   - Un même pattern de modules à chaque fois, pour garder la cohérence.
   - Pouvoir me connecter à d'autres bases de données de la même instance RDS selon l'endpoint.

Peux-tu, dès le prochain chat, proposer :  
- L’ossature complète du projet (arborescence).  
- Un exemple de **config.py**, **db.py**, **repository.py**, **services.py**, **routes.py**, **app.py**, **requirements.txt**  
  respectant ces principes et permettant de déclarer des endpoints paramétrés sur du SQL brut de manière sécurisée, réutilisable et maintenable ?  
